#pragma once

// see https://cmake.org/cmake/help/latest/command/configure_file.html
#cmakedefine01 ULAYFS_MEM_PROTECT
#cmakedefine01 ULAYFS_NO_SHARING
#cmakedefine01 ULAYFS_RELAXED
#cmakedefine01 ULAYFS_USE_MAP_SYNC
#cmakedefine01 ULAYFS_FORCE_MAP_POPULATE
#cmakedefine01 ULAYFS_TX_FLUSH_ONLY_FSYNC
#cmakedefine01 ULAYFS_USE_PMEMCHECK
#cmakedefine01 ULAYFS_USE_LIBPMEM2
#cmakedefine ULAY_PERSIST_IMPL PersistImpl::@ULAY_PERSIST_IMPL@

#cmakedefine GIT_BRANCH "@GIT_BRANCH@"
#cmakedefine GIT_COMMIT_HASH "@GIT_COMMIT_HASH@"
#cmakedefine CMAKE_BUILD_TYPE "@CMAKE_BUILD_TYPE@"

#include <ostream>

namespace ulayfs {

constexpr static struct BuildOptions {
  constexpr static const char* build_type = CMAKE_BUILD_TYPE;
  constexpr static const char* git_branch = GIT_BRANCH;
  constexpr static const char* git_commit_hash = GIT_COMMIT_HASH;

  constexpr static bool mem_protect = ULAYFS_MEM_PROTECT;
  constexpr static bool no_sharing = ULAYFS_NO_SHARING;
  constexpr static bool relaxed = ULAYFS_NO_SHARING || ULAYFS_RELAXED;
  constexpr static bool use_map_sync = ULAYFS_USE_MAP_SYNC;
  constexpr static bool force_map_populate = ULAYFS_FORCE_MAP_POPULATE;
  constexpr static bool tx_flush_only_fsync = ULAYFS_TX_FLUSH_ONLY_FSYNC;
  constexpr static bool use_pmemcheck = ULAYFS_USE_PMEMCHECK;
  constexpr static bool use_libpmem2 = ULAYFS_USE_LIBPMEM2;

#ifdef NDEBUG
  constexpr static bool debug = false;
#else
  constexpr static bool debug = true;
#endif

#ifdef __CLWB__
  constexpr static bool support_clwb = true;
#else
  constexpr static bool support_clwb = false;
#endif

#ifdef __CLFLUSHOPT__
  constexpr static bool support_clflushopt = true;
#else
  constexpr static bool support_clflushopt = false;
#endif

  // for memset and memcpy with persistence:
  enum class PersistImpl {
    KERNEL,  // use Linux kerne's implementation (w/ movnti)
    PMDK,    // use PMDK's implementation
    FLUSH,   // do operation on cache then flush (not recommended)
  };
  constexpr static enum PersistImpl persist_impl =
      (!use_libpmem2 && ULAY_PERSIST_IMPL == PersistImpl::PMDK)
          ? PersistImpl::KERNEL
          : ULAY_PERSIST_IMPL;

  friend std::ostream& operator<<(std::ostream& out,
                                  [[maybe_unused]] const BuildOptions& opt) {
    out << "BuildOptions: \n";
    out << "\tbuild_type: " << build_type << "\n";
    out << "\tgit_branch: " << git_branch << "\n";
    out << "\tgit_commit_hash: " << git_commit_hash << "\n";
    out << "\tdebug: " << debug << "\n";
    out << "\tuse_pmemcheck: " << use_pmemcheck << "\n";
    out << "\tmem_protect: " << mem_protect << "\n";
    out << "\tno_sharing: " << no_sharing << "\n";
    out << "\trelaxed: " << relaxed << "\n";
    out << "\tuse_map_sync: " << use_map_sync << "\n";
    out << "\tforce_map_populate: " << force_map_populate << "\n";
    out << "\ttx_flush_only_fsync: " << tx_flush_only_fsync << "\n";
    out << "\tsupport_clwb: " << support_clwb << "\n";
    out << "\tsupport_clflushopt: " << support_clflushopt << "\n";
    out << "\tpersist_impl: " << [&]() -> const char* {
      switch (persist_impl) {
        case PersistImpl::KERNEL:
          return "KERNEL";
        case PersistImpl::PMDK:
          return "PMDK";
        case PersistImpl::FLUSH:
          return "FLUSH";
        default:
          assert(false);
          return "UNKNOWN";
      }
    }() << "\n";
    return out;
  }
} build_options;

static struct RuntimeOptions {
  bool show_config{true};
  bool strict_offset_serial{true};
  const char* log_file{};
  int log_level{1};

  RuntimeOptions() noexcept {
    if (std::getenv("ULAYFS_NO_SHOW_CONFIG")) show_config = false;
    if (std::getenv("ULAYFS_NO_STRICT_OFFSET")) strict_offset_serial = false;
    log_file = std::getenv("ULAYFS_LOG_FILE");
    if (auto str = std::getenv("ULAYFS_LOG_LEVEL"); str)
      log_level = std::atoi(str);
  };

  friend std::ostream& operator<<(std::ostream& out,
                                  const RuntimeOptions& opt) {
    out << "RuntimeOptions: \n";
    out << "\tshow_config: " << opt.show_config << "\n";
    out << "\tstrict_offset_serial: " << opt.strict_offset_serial << "\n";
    out << "\tlog_file: " << (opt.log_file ? opt.log_file : "None") << "\n";
    out << "\tlog_level: " << opt.log_level << "\n";
    return out;
  }
} runtime_options;

}  // namespace ulayfs
