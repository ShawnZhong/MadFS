#pragma once

// see https://cmake.org/cmake/help/latest/command/configure_file.html
#cmakedefine01 ULAYFS_MEM_PROTECT
#cmakedefine01 ULAYFS_NO_SHARING
#cmakedefine01 ULAYFS_RELAXED
#cmakedefine01 ULAYFS_USE_MAP_SYNC
#cmakedefine01 ULAYFS_FORCE_MAP_POPULATE
#cmakedefine01 ULAYFS_TX_FLUSH_ONLY_FSYNC
#cmakedefine01 ULAYFS_USE_PMEMCHECK
#cmakedefine01 ULAYFS_USE_LIBPMEM2

// clang-format off
#cmakedefine ULAYFS_PERSIST @ULAYFS_PERSIST@
#define ULAYFS_PERSIST_STR "@ULAYFS_PERSIST@"
// clang-format on

#cmakedefine CMAKE_BUILD_TYPE "@CMAKE_BUILD_TYPE@"

#include <ostream>

namespace ulayfs {

constexpr static struct BuildOptions {
  constexpr static const char* build_type = CMAKE_BUILD_TYPE;
  constexpr static bool mem_protect = ULAYFS_MEM_PROTECT;
  constexpr static bool no_sharing = ULAYFS_NO_SHARING;
  constexpr static bool relaxed = ULAYFS_NO_SHARING || ULAYFS_RELAXED;
  constexpr static bool use_map_sync = ULAYFS_USE_MAP_SYNC;
  constexpr static bool force_map_populate = ULAYFS_FORCE_MAP_POPULATE;
  constexpr static bool tx_flush_only_fsync = ULAYFS_TX_FLUSH_ONLY_FSYNC;
  constexpr static bool use_pmemcheck = ULAYFS_USE_PMEMCHECK;

#ifdef NDEBUG
  constexpr static bool debug = false;
#else
  constexpr static bool debug = true;
#endif

#ifdef __CLWB__
  constexpr static bool support_clwb = true;
#else
  constexpr static bool support_clwb = false;
#endif

#ifdef __CLFLUSHOPT__
  constexpr static bool support_clflushopt = true;
#else
  constexpr static bool support_clflushopt = false;
#endif

#ifdef __AVX512F__
  constexpr static bool support_avx512f = true && !use_pmemcheck;
#else
  constexpr static bool support_avx512f = false;
#endif

  // for memset and copy with persistence:
  enum class Persist {
    NATIVE,  // do operation on cache then flush
    KERNEL,  // use Linux kerne's implementation (w/ movnti)
    PMDK,    // use PMDK's implementation
  };
  constexpr static enum Persist persist = Persist::ULAYFS_PERSIST;

  friend std::ostream& operator<<(std::ostream& out,
                                  [[maybe_unused]] const BuildOptions& opt) {
    out << "BuildOptions: \n";
    out << "\tbuild_type: " << build_type << "\n";
    out << "\tdebug: " << debug << "\n";
    out << "\tuse_pmemcheck: " << use_pmemcheck << "\n";
    out << "\tmem_protect: " << mem_protect << "\n";
    out << "\tno_sharing: " << no_sharing << "\n";
    out << "\trelaxed: " << relaxed << "\n";
    out << "\tuse_map_sync: " << use_map_sync << "\n";
    out << "\tforce_map_populate: " << force_map_populate << "\n";
    out << "\ttx_flush_only_fsync: " << tx_flush_only_fsync << "\n";
    out << "\tsupport_clwb: " << support_clwb << "\n";
    out << "\tsupport_clflushopt: " << support_clflushopt << "\n";
    out << "\tsupport_avx512f: " << support_avx512f << "\n";
    out << "\tpersist_impl: " ULAYFS_PERSIST_STR << "\n";
    return out;
  }
} build_options;

static struct RuntimeOptions {
  bool show_config{true};
  bool strict_offset_serial{true};
  const char* log_file{};
  int log_level{1};

  RuntimeOptions() noexcept {
    if (std::getenv("ULAYFS_NO_SHOW_CONFIG")) show_config = false;
    if (std::getenv("ULAYFS_NO_STRICT_OFFSET")) strict_offset_serial = false;
    log_file = std::getenv("ULAYFS_LOG_FILE");
    if (auto str = std::getenv("ULAYFS_LOG_LEVEL"); str)
      log_level = std::atoi(str);
  };

  friend std::ostream& operator<<(std::ostream& out,
                                  const RuntimeOptions& opt) {
    out << "RuntimeOptions: \n";
    out << "\tshow_config: " << opt.show_config << "\n";
    out << "\tstrict_offset_serial: " << opt.strict_offset_serial << "\n";
    out << "\tlog_file: " << (opt.log_file ? opt.log_file : "None") << "\n";
    out << "\tlog_level: " << opt.log_level << "\n";
    return out;
  }
} runtime_options;

}  // namespace ulayfs
